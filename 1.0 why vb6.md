
An example of RAD CQRS
--------------------------------

- It means it is implemented in vb6. 
- But it is not just vb6 -- the reasoning is: if we can do it in vb6, we can do it in anything. 
- More importantly, vb6 is the king of RAD, so, it means an example of RAD CQRS -- after vb6, we can apply the same approach for c# or java or javascript.

- More specifically, DTOs are not classes, not even custom types. Instead, we use dictionaries ("D"), or, dictionaries of dictionaries ("DD").   
    * All keys and values in the dictionary are strings. 
    * We use JSON also; and, the values in JSON are always strings.
        
- Remove "DDD". As explained above, because we use DD, no classes, so, no DDD anymore. 
    * However, this does not mean the key ideas in DDD are all gone. They are "reduced" (crystalized) as relational concepts, or, dictionary concepts.  
    
- Relax "web servbices": Because a vb6 appliaction is typically deployed as 2-tier, so, the concept of "web service" is relaxed: somtimes in  facades, we can prompt a msgbox. The reasoning is: it is RAD; we can always fix those msgboxes when we really need to deploy it as a web service.

    * Based all above, CQRS now means that all facades should be split into two groups: query facades and command facades. 
    * In other words, the split or "seapration" in CQRS is only in facades, not in database.
    
Data-binding and transacction, optimistic concurrency
----------------------------------------------------------------------

- The number one reason to split all facades into two groups, is that in query facades, we can use data-binding.

- A less important reason is, in command facades, when necesary, we must handle transacction and optimistic concurrency, and sometimes, we need to use "async" (a.k.a. "evential consistent") model, and therefore, we need to add some queue tables.  
    * Again, the necesary split or "seapration" in CQRS is in facades, not necessarily in database.
    
